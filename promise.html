<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Promise</title>
</head>

<body>
    <script>
        //resolve,reject,all,ract

        let promise=new Promise((resolve,reject)=>{
            // resolve(123)
            // reject(111)
        })

        promise.then(res=>{
            console.log(res)
            console.log('resolve')
        }).catch(error=>{
            console.log('reject')
        })


        function promise1(status){
            return new Promise((resolve,reject)=>{
                if(status){
                    resolve('第一个成功')
                }else{
                    reject('第一个失败')
                }
            })
        }

        function promise2(status){
            return new Promise((resolve,reject)=>{
                if(status){
                    resolve('第2个成功')
                }else{
                    reject('第2个失败')
                }
            })
        }

        //all方法内，数组内有promise必须全部成功才执行then回调，一个不成功就会执行catch
        Promise.all([promise1(true),promise2(true)]).then(res=>{
            console.log('全部调用成功')
        }).catch(error =>{
            console.log(error)
        })


        //数组promise中，只要有一个返回resolve就会返回then但是如果第一个返回reject则会进入catch
        Promise.race([promise1(true),promise2(true)]).then(res=>{
            console.log('全部调用成功')
        }).catch(error =>{
            console.log(error)
        })


        promise1(true).then(res=>{
            console.log(res)
        }).catch(error=>{
            console.log(error)
        })


    </script>

</body>

</html>